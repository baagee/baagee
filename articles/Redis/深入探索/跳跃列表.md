# 跳跃列表

redis的zset是个复杂的结构，一方面他需要一个hash结构来储存value的socre的关系，另一方面还需要根据score排序，还要支持根据指定的score的范围获取value列表的功能，这时候就需要一个跳跃列表的结构了。
zset的内部实现是一个hash字典加一个跳跃列表skiplist，下面大致讲一下skiplist结构。
## 基本结构
跳跃列表的示意图，图中只画了四层。
![aIH0Wn.png](https://s1.ax1x.com/2020/08/08/aIH0Wn.png)
Redis 的跳跃列表共有64层。每一个kv (key/value)块对应的结构如下面的代码中的zslnode结构，kv header也是这个结构，只不过value字段是NULL值无效的，
score 是Double.MIN_VALUE,用来垫底的。kv 之间使用指针串起来形成了双向链表结构，它们是有序排列的，从小到大。不同的kv层高可能不一样，层数越高的kv越少。同一层的kv会使用指针串起来。每一个层元素的遍历都是从kv-header出发。
```
struct zslnode{
    string value;
    double score;
    zslnode*[] forwards;//多层链接指针
    zslnode* backword;//回溯指针
}
struct zsl{
    zslnode* header;//跳跃列表表头指针
    int maxLevel;//跳跃列表当前最大层级
    map<string, zslnode*> ht;//hash结构的所有键值对
}
```

## 查找过程
我们要定位到那个紫色的w，需要从header的最高层开始遍历找到第一个节点(最后一个比“我"小的元素，然后从这个节点开始降一层再遍历找到第二个节点(最后一个比“我”小的元素)，然后一直降到最底层进行遍历就找到了期望的节点(最底层的最后个比我“小”的元素)。
我们将中间经过的一系列节点称之为“搜索路径”，它是从最高层一直到最低层的每一层最后一个比“我”小的元素节点列表。
![aIXK29.png](https://s1.ax1x.com/2020/08/08/aIXK29.png)
有了这个搜索路径，我们就可以插入这个新节点了。不过这个插入过程也不是特别简单。因为新插入的节点到底有多少层，得有个算法来分配一下， 跳跃列表使用的是随机算法。

## 随机层数
对于每一个新插入的节点，都需要调用一个随机算法给它分配一个合理的层数。直观上期望的目标是50%的概率被分配到Level1, 25%的概率被分配到Level2,12.5%的概率被分配到Level3,以此类推。

不过Redis标准源码中的晋升率只有25%,所以官方的跳跃列表更加的扁平化，层高相对较低，在单个层上需要遍历的节点数量会稍多一点。
也正是因为层数一般不高，所以遍历的时候从顶层开始往下遍历会非常浪费。跳跃列表会记录一下当前的最高层数maxLevel，遍历时从这个maxLevel开始遍历，性能就会提高很多。
## 插入过程
首先我们在搜索合适插入点的过程中将“搜索路径”找出来，然后就可以开始创建新节点。创建的时候需要给这个节点随机分配一个层数，再将搜索路径上的节点和这个新节点通过前向后向指针串起来。如果分配的新节点的高度高于当前跳跃列表的最大高度，就需要更新一下跳跃列表的最大高度。
## 删除过程
删除过程和插入过程类似，都需要首先把搜索路径找出来，然后对于每个层的相关节点重新排一下前后指针，同时还需要更新一下最高层级maxLevel。
## 更新过程
当我们调用zadd方法时，如果对应的value不存在，那就是插入过程。如果这个value已经存在了，只是调整一下score的值，那就需要走一个更新流程。假设这个新的score值不会带来排序上的改变，那么就不需要调整位置，直接修改元素的score值就可以了。但是如果排序位置改变了，那就要调整位置。那么该如何调整位置呢?
一个简单的策略就是先删除这个元素，再插入这个元素，需要经过两次路径搜索，Redis就是这么么干的。值改变了的情况就直接删除后再插入 。 不过Redis遇到score值中的代码似乎还有优化空间，不会去判断位置是否需要调整
## score一样的情况
在一个极端的情况下，zset中所有的score值都是一样的，如何排序？如果score值相同还需要再比较value值,所以zset的排序元素不只看score值，

## 元素排名怎么算出来的？
zset可以获取元素的排名rank，怎么算的呢？redis在skiplist的forward指针上进行了优化，给每个forward的指针增加了span属性，span就是跨度的意思，标示从当前层级的前一个节点forward
指针跳到当前这个节点中间会跳过多少个节点。在插入，删除操作时都会更新span的大小。
这样但我们要计算一个元素的排名时，只需要将搜索路径经过的所有节点的跨度span值进行叠加就可以计算出最终的rank。



