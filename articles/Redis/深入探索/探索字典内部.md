# redis字典结构

字典是redis里面用的最频繁的数据结构，除了hash以外，redsi里面保存所有key和value也组成了一个全局字典。
还有带有过期时间的key集合也是一个字典。zset集合储存了value和score的映射也是通过字典结构实现的。

## 字典的内部结构
字典结构包含两个hashtable，通常情况下只有一个hashtable会有值。在扩容，缩容时需要分配新的hashtable，然后进行渐进式迁移。
等待迁移结束后，旧的hashtable就会被删除。
```
struct dict{
    dictht ht[2]
}
```

 ![a6GtEj.md.png](https://s1.ax1x.com/2020/08/05/a6GtEj.md.png)
 
 
所以，字典数据结构的精华就落在了hashtable结构上了。hashtble 的结构和Java的HashMap几乎是一样的， 都是通过分桶的方式解决hash冲突。
第一维是数组，第二维是链表。数组中存储的是第二维链表的第一个元素的指针。
![a6YK6f.md.png](https://s1.ax1x.com/2020/08/05/a6YK6f.md.png)

大字典的扩容是比较耗时间的，需要重新申请新的数组，然后将旧字典所有链表中的元素重新挂接到新的数组下面，这是一个O(n)级别的操作，
作为单线程的Redis很难承受这样耗时的过程，所以Redis使用渐进式rehash小步搬迁。虽然慢一点，但是肯定可以搬完。
搬迁操作来自当前字典的后续操作命令，比如hset。redis也会定时任务对字典进行搬迁。

## 查找过程
插入和删除操作都依赖于查找，必须先把元素找到，才可以进行数据结构的修改操作。hashtable 的元素是在第维的链表上，
所以我们首先要想办法定位出元素在哪个链表上。
值得注意的是代码中的hash fune，它会将key映射为一个整数，不同的key会被映射成分布比较均匀散乱的整数。只有hash值均匀了，
整个hashtable才是平衡的，所有的二维链表的长度就不会差距很远，查找算法的性能也就比较稳定。

## hash函数
hashtable的性能好不好完全取决于hash函数的质量。如果hash函数可以将key打散得比较均匀，那么这个hash函数就是个好函数。
Redis 的字典默认的hash函数是siphash。siphash 算法即使在输入key很小的情况下，也可以产生随机性特别好的输出，而且它的性能也非常突出。
对于Redis这样的单线程来说，字典数据结构非常普遍，字典操作也会非常频繁，hash 函数自然是越快越好。

### hash攻击
如果hash函数存在偏向性，黑客就可能利用这种偏向性对服务器进行攻击。存在偏向性的hash函数在特定模式下的输入会导致hash第二维链表长度极为不均匀，
甚至所有的元素都集中到个别链表中，直接导致查找效率急剧下降，从O(1)退化到O(n),有限的服务器计算能力将会被hshtable的查找效率彻底拖垮。
这就是所谓的hash攻击。


## 扩容条件
正常情况下，`当hash表中元素的个数等于第一维数组的长度`时，就会开始扩容，扩容的新数组是原数组大小的2倍。不过如果Redis正在做bgsave,
 为了减少内存页的过多分离(Copy On Write)，Redis 尽量不去扩容，但是如果hash表已经非常满了，`元素的个数已经达到了第一维 数组长度的5倍`，
 说明hash表已经过于拥挤了，这个时候就会强制扩容。


## 缩容条件
当hash表因为元素逐渐被删除变得越来越稀疏时，Redis会对hash表进行缩容来减少hash表的第一维数组空间占用。缩容的条件是`元素个数低于数组长度的10%`。缩容不会考虑Redis是否正在做bgsave.

## set的结构
Redis里面set的结构底层实现也是字典，只不过所有的value都是NULL,其他特性和字典一模一样。
