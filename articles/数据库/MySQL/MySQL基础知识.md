### Myisam 与 InnoDB 的区别 
1. Myisam 在插入数据和查询数据的时候都比 InnoDB 效率高 
2. InnoDB 在更新和删除的时候比 Myisam 效率高 
3. InnoDB 支持事务，安全，Myisam 不支持  

### 如何选择存储引擎？ 
1. 基本可以使用数据库默认的存储引擎（InnoDB） 
2. 如果在需要事务处理的时候，只能选择 InnoDB 
3. 数据本身以插入和查询为主，那么可以使用 Myisam  

#### SQL 语言是一种强类型语言，在为数据进行定义的时候，必须要指定数据类型。 
浮点数会丢失精度   
float：最大有效位 7 位左右   
double：最大有效位为 15 位左右  
浮点数的使用方式 float(M,D)：M 表示整个长度，D 表示小数位的长度 

定点型：
    decimal 能够自动的扩展宽度来保存数据，保证数据的精度，基于小数部分，如果超出指定长度，仍然会进行四舍五入。 
    语法：decimal(M,D)：M 表示总长度，D 表示小数部分的长度 凡是涉及到钱的都会在数据库端使用 decimal 来进行数据的存储和运算。  

### 如何区分使用 char 还是 varchar 
1. 所有字符串长度都必须在 255 之内 
2. 如果字符串长度是固定，那么使用 char md5 值，身份证，手机号等等 
3. 如果字符串长度不固定，那么使用 varchar 姓名，邮箱。。。  

### char 和 varchar 区别 
1. char 的效率比 varchar 要高 
2. varchar 比 char 节省空间  
当字符串长度超过 255 之后，就不会使用 varchar 来进行数据的保存，使用 text  
text：字符串文本 
blob：二进制文本 在记录里面不计算长度（不占记录长度），基本可以“无限”存储数据 
### enum枚举类型
enum：枚举，列出一系列的元素，可以从一堆元素中任选一个作为实际的值（单选框） 语法：enum(元素 1，元素 2…) ，下标从1开始

#### 枚举的意义？ 
1. 限制用户的输入（规范数据） 
2. 能够节省磁盘空间  
枚举使用 2 个字节来保存数据，能够保存 65535 个数据，是因为枚举实际保存的不是字符串而是字符串元素所对应 的数值。   
如何证明枚举实际存储的是数值呢？ 使用算术运算符：mysql 会在碰到算术运算符之后，自动进行数据转换，转换成数值类型。转换的标准与 PHP 一致。 语法：select 字段 + 0 from 表名 

### 时间
datetime：表示年月日时分秒，能够表示 9000 年，占用 8 个字节 
timestamp：时间戳，使用标准整型存储，表现却是年月日，时分秒 时间戳并不能使用真正的时间戳 
date：日期部分，可以表示 1000-9999 年 
time：时间部分，表示的是一个时间段，从过去什么时间到以后的某个时间 
year：年，使用一个字节存在，一个字节只能表示 256 个数值，在计算的时候加上 1900 再输出  
### primary key 
主键，主要的键，用主键修饰的字段，该字段具有唯一性（不能重复） 
1. 一张表最多只能有一个主键 
2. 主键字段不能为空  

### auto_increment 
自动增长 
1. 字段必须是整型 
2. 必须保证使用自动增长的字段首先满足的一个条件：是一个索引字段 
3. 一张表只能有一个自动增长 
4. 自动增长通常是配合逻辑主键（id int primary key auto_increment） 
注意：auto_increment 的值的修改，被修改的新值，必须要比当前表中已经存在的自增长的值要大。  

### unique key 
唯一键，字段的值不能重复 1. 一张表唯一键可以有多个 2. 唯一键不对 null 进行处理  
如何添加唯一键？ 跟主键的添加方式基本相同 
1. 在字段之后直接跟 unique key 
2. 在表的所有字段之后，使用 unique key(字段列表) 
3. 在修改表结构的时候增加唯一键：alter table 表名 add unique key(字段列表)  
注意：当唯一键字段不能为 null 之后，会自动转换成主键（主键只是表现上是主键，实质还是唯一键） 
唯一键转主键： 
1. 该唯一键不能为空 
2. 该唯一键是第一个不为空的唯一键   第一个不为空的唯一建变成主键

### 外键定义
在一张表中创建一个字段，该字段指向另外一张表的主键。通过一定的约束语句来指明其联系。  
#### 外键规则： 
1. 外键的字段类型与被指向的表的主键的字段类型一致 
2. 如果想要实现 on delete set null，外键字段必须可以为空  
#### 添加外键
1. 可以通过在创建表的时候，指定对应的外键 
语法：foreign key(当前表中的外键字段) references 外键指向的表(外键指向表的主键); 
2. 修改表的结构增加外键（指定外键名字） 
alter table 表名 add constraint 外键名 foreign key(字段) references 父表(主键) 前提：子表中没有父表中不存在的值   
父表：外键所指向的那张表称之为父表 
子表：外键所在的表就是子表  
外键的作用主要是用来约束外键所在表的数据的操作以及外键所指向的表的操作 1. 一旦一张表有一个外键字段，那么该表外键字段值，就不能是外键所指向的表中的主键的值之外的值 

#### 修改外键
外键不能被修改，只能先删除后增加 

#### 删除外键 
一张表中可能存在多个外键，所以在删除外键的时候，必须指定外键名称。 
语法：alter table 表名 drop foreign key 外键名字 
只会删除外键信息，索引不会被删除
修改外键作用 
修改外键的约束作用，修改外键对父表的操作约束。 默认的，对父表的约束操作是不允许删除和更新。 
#### 修改外键对父表的约束  
置空：set null，当父表进行更新或者删除的时候，对应的子表里的数据应该被设置成 null  
级联：cascade，当父表进行更新或者删除的时候，对应的子表里的数据应该被删除或者被更新 
在增加外键的时候指定约束方式。 
on delete set null on update cascade：当父表删除记录时，子表置空，当父表更新记录时子表跟着更新 

#### 外键的优缺点 
##### 优点：
###### 从数据库管理者出发 
1. 能够保证数据的一致性（父表修改之后，子表跟着修改） 
2. 保证数据的安全性（不允许在子表中增加父表中不存在的值） 
3. 将表与表之间的关心进行了关联（体现了关系型数据库）  
###### 从 PHP 开发者出发 
4. 增加了维护的难度  
实际开发中，一般会使用外键字段，但是不使用外键约束。通过程序来实现表与表之间的关系维护。

### 数据表设计三范式
#### 第一范式：1NF 字段原子性
数据表的设计的字段中，每个字段都不能再分，每个字段都必须是最小的不可分割的单位（原子性） 

#### 第二范式：2NF 尽量不用复合主键
一个数据表中的字段只能依赖一张表中的全部主键，而不能够依赖部分主键（主键是复合主键），第二范式的任务 就是取消部分依赖
满足第二范式：在表中尽量不使用复合主键，使用逻辑主键 

#### 第三范式：3NF 解决字段冗余 
在第二范式的前提上，如果在一个表中，出现了的数据会在其他实体（表）中出现，那么该类数据就应该统一拿出 来新建一张表来进行维护。如果一个字段，依赖一个表中的非主键字段，这个时候就称之为传递依赖，就应该将该字段以及依赖的字段取出，重新维护一张表。

满足第三范式：不同的实体创建不同的表，实体之间有关联的话，增加一个字段保存对应其他实体中记录的主键 满足第三范式主要解决数据冗余的问题。 

### 数据库操作
#### 增加数据 
基本方式：insert into 表名 [(字段列表)] values (值列表)；  
主键冲突：在插入数据的时候，主键值已经存在了，但是要求是必须使用该主键字段 
实现目标：如果该主键不存在那么就增加记录，如果存在，就修改部分字段的值 
1. 使用主键冲突方式 
语法：insert into 表名 values(值列表) on duplicate key update 字段 = 值 
2. 使用替换插入 
replace into 表名 (字段列表) values(值列表)
replace 其实先删除存在的行，再进行插入。  
注意：大部分情况下，因为是使用逻辑主键，一般会自增长，所以使用 null 即可（insert），但是如果是使用业务主 键，那么很有可能会存在冲突（replace）。  

蠕虫复制 蠕虫能够一分为 2,2 分为 4，在成倍增长 
语法：insert into 表名 (字段列表) select 字段列表 from 表名; 

#### 更新数据 
基本语法：update 表名 set 字段 = 值 [where 条件] 
高级语法：update 表名 set 字段 = 值 [where 条件]  [limit]   
#### 删除数据 
基本语法：delete from 表名 [where 条件] 
高级语法：delete from 表名 [where 条件] [limit]   
##### 删除数据并不能修改一张表的索引和自增长
如果想删除表的自增长重新来过 先删除表（drop），再新建表（create） 
mysql 提供了简单方式实现两个步骤：truncate tableName

#### 查询数据 
基础语法：select 字段列表 from 表名 [where 条件] 
高级语法：select [select选项] 表达式 [from子句] [where子句] [group by 子句] [having 子句] [order by子句] [limit 子 句]  

##### select 选项
在查询得到数据是否需要进行合并，all 表示获取所有数据（默认的），distinct 将完全一致的记录进行 合并   

##### where 子句 
依据条件筛选数据 where 如何筛选时数据？
通过运算符来进行数据筛选 
运算符：  比较运算符：>，>=，<，<=，=（比较），!=，<>，in，between and，is [not]null    is null 判断数据是否为 null 
如果字段的值为 null，那么该字段与任何值的运算的结果都是 null in：表示某个字段的值，在某个集合（包含多个数据）中 
where 是针对元数据进行操作，所有 where 之后的语句，都是针对数据结果进行操作，而不是针对数据表。

##### group by 
分组之后，会将数据进行合并，从而只象征性的保留每组的第一条记录。 通常 group by 不是为了得到分组后的每组的全部数据，而是用来统计每组的信息。  

##### 统计函数：都是数学统计  
count：统计所有的记录的个数，也可以是所有字段（不统计 null） 
max：统计分组后每组里面的最大值，通常是某个字段  
min：统计最小  
avg：统计平均数  
sum：求和   
group by 排序：能够直接排序 
语法：group by 字段 [asc|desc] 根据分组字段进行排序   
多字段分组：按照某个字段进行分组之后，将分组得到的数据再按照某个条件进行分组。 

##### having 子句 
having 子句功能与 where 一样，用于做条件判断  
where：对数据源进行条件处理  
having：对 where 得到数据内存进行处理 
不同点：having 可以使用字段别名，而 where 不能 
不同点：having 可以使用统计函数 

##### order by 子句 
主要是对字段进行排序，有两种方式：asc 默认的，desc 降序排序，比较的依据是校对集。 

##### limit 子句 
理解的是限制查找过程中返回数据的条数 实际：限制数据查询的起始位置和返回数据的条数 语法：limit offset,number  offset：从查询得到结果中的第几条开始，在数据库里，offset 从 0 开始  number：一共返回多少记录（返回的记录数不一定完全等于 number 数量）  
通常 limit 用于实现数据的分页。 

##### 联合查询 union
将两个查询的结果，合并到一起，将记录数合并，而字段数不变 联合查询必须满足的条件 1. 两个查询得到的字段数必须一致  
语法：select 语句 union [union 选项] select 语句 
union 选项：all 和 distinct（默认的） 
在 union 中使用 order by 必须对 select 语句进行括号处理 
在 union 中使用 order by 必须配以 limit 才能生效 
大数据处理，往往一个网站系统当数据量很大的时候，会进行数据的分表操作，将同样的数据存放在不同的表中， 因为一张表的数据太大会影响数据查询的效率，增加维护的难度。所以，一般这样的数据的都是分表存放，但是在 某些操作的时候，需要将所有的数据放到一起，这时会就使用联合查询。 

##### 连接查询 
概念：将多个表中相关的数据记性字段上面的增加，从而使得最终的结果能够完全显示数据信息 连接查询根据查询结果以及条件的不一样可以分为几类： 1. 内连接 2. 外连接 3. 自然连接 4. 交叉连接 
###### 内连接 
如果一张表的记录（有个字段记录另外一张表的主键），能够在另外一张表中匹配上，那么就保存，否则就不保存。 
左表：join 关键字左边的表称之为左表 
右表：join 关键字右表的表称之为右表  
语法：左表 [inner] join 右表 on/where 连接条
内连接的 on 条件可以使用 where 来进行匹配 
内连接还可以通过使用多表查询，但是使用条件匹配来实现 
select * from table_1 t1,table_2 t2 where t1.id=t2.XX
###### 外连接 
与内连接相似，如果主表（左外连接左表为主表，右外连接右表为主表）的记录在副表中匹配不上，那么该记录依 然保留，只是副表字段都置空 
语法：左表 left/right [outer] join 右表 on 连接条件 
左外连接：以左表为主表，使用关键字 left 
右外连接：以右表为主表，使用关键字 right 
###### 内连接与外连接的区别 
1. 内连接的条件可以使用 where 关键字，外连接不行 
2. 内连接可以没有条件，而外连接必须指定条件 
3. 内连接只保留匹配成功的记录，而外连接会保留主表的全部记录  
###### 交叉连接
笛卡尔积 
语法：左表 cross join 右表 
两个表之间的连接不需要指定连接条件，系统自动找条件，并按照条件进行处理。 自然连接可以包含内连接，外连接和交叉连接 

###### 自然连接
自动寻找连接条件：会判断两张表中是否有同样的字段名称，如果有，则作为连接条件，否则就没有条件  
语法：左表 natural [left/right] join 右表  
左表 natural join 右表：自然内连接  左表 natural [left/right] join 右表：自然外连接  
自然连接，会合并相同的字段   
自然连接：无论两张表中有多少同名字段，通通拿过来作为连接条件。 

##### 子查询 
子查询：subquery，一条查询语句在另外一条查询语句当中，那么该查询语句就是子查询。  
一条 Select 查询语句得到的结果可能有哪些？ 1. 一张表 2. 一行 3. 一个列     4. 一个字段  
基于查询得到的结果，那么可以对子查询进行以下分类 
1. 标量子查询：子查询返回的结果是一个字段单元 
2. 列子查询：子查询返回的结果是一个字段，但是有多个值 
3. 行子查询：子查询返回的结果是一行记录（一条记录：大于一个字段） 
4. 表子查询：返回的结果是一个二维表（多行多列） 
###### 标量子查询 
通常，标量子查询是用于作为整条查询语句条件部分中的比较运算 
select * from student where class_id = (select c_id from class where name=’php140706’); 
###### 列子查询 
列子查询也是用于主查询的查询条件  
需求：用户知道班级名称（PHP140507，PHP140310），想得到班级所有的学生信息。 
select c_id from class where name = 'PHP140508' or name = 'PHP140310'; -- 2,3 
select * from student where class_id in (2,3); 
select * from student where class_id in (select c_id from class where name = 'PHP140508' or name = 'PHP140310')  

###### 行子查询 
也是用于主查询的条件判断 
思路 1. 找出最大的年龄和最高的身高 select max(age),max(height) from student; 2. 在查询条件中比较最大的值 select * from student where 年龄和身高匹配  
行子查询需要构造行元素，通过使用括号，将多个字段放到一起，形成“行”，再使用行与子查询得到的“行”进 行比较。  
行子查询   
select * from sss where (age,height)=(select max(age),max(height) from sss);

###### 表子查询 
用于作为数据源，出现在 from 之后  
需求：获取每个班级中身高最高的一个学生 
1. 先将班上所有学生按照身高降序排序 
2. 再对排序好的数据进行分组即可  
当一个子查询作为数据源的时候，必须要将该数据源命名成表的形式（一个名字），所以表子查询得到的结果必须 要使用别名  
select * from (select * from student order by height desc) as sss where 1 group by class_id

通过子查询出现的位置，也可以对子查询进行分类 
1. from 子查询：表子查询
2. where 子查询：变量，行，列子查询 
3. exists 子查询：用来判断查询条件，exists 返回的结果是一个布尔值 exists 子查询适用于：主查询查询的结果非常大，但是又特别依赖某个条件（主查询要么获取全部，要么一个都 不要）   

### 视图 
指的是一个实体影像，就是影子的意思。 
视图就是通过表数据来影射的虚拟表，能够将表中的数据影射出来，但是实际上自己并不保存（没有）数据。 
#### 创建视图 
语法：create view 视图名字 as select 查询 视图简单的分为两种 
1. 单表视图：select 语句是从一张表中得到数据 
2. 多表视图：select 语句是从多张表中得到数据 
##### 系统的变化？ 
1. 会产生一个“表”  
2. 会产生一个表结构文件 
#### 查看数据：
select 字段列表 from 视图名字 
注意：通过视图所看到的最终的数据，都不是视图本身所保存的数据，而通过执行视图的 select 语句所即时查询到 的数据  
#### 修改视图 
修改视图就是修改 select 语句 语法：alter view 视图名字 as select 语句 
#### 删除视图 
语法：drop view 视图名字 
##### 系统所做的事情？ 
1. 删除了视图本身 
2. 删除了视图创建时所产生的结构文件   

#### 视图的数据操作 
就是对视图的数据进行增删改查。 
单表视图增删改查操作，但是视图的数据操作实际上是对视图的基表的数据操作 
基表：T:a not null,b ,c not null,d 
视图 1：select a,b,c from T，插入数据会成功，只有 d 字段没有插入值，d 字段值为 null，但是 d 字段允许 null，所 以数据操作成功 
视图 2：select a,b,d from T，插入数据会失败，因为没有 c 字段值，c 字段默认会被设成 null，但是 c 字段不能为 null， 所以数据插入失败  

视图能否插入数据全看视图的中的字段，是否包含基表中全部不为 null 的字段，如果全部包含，那么就可以插入数 据；否则不能插入数据。（前提：该实体是单表视图）  

多表视图不能进行增删操作，改是可以的。 

#### 视图算法 
当视图被查询的时候，系统会根据一定的解释方式来对 SQL 语句进行处理操作  
视图算法有三种  
merge：合并，将外部的 select 语句与视图的 select 语句进行合并，合并之后再执行  
temptable：临时表，将视图先执行，把结果存放成一张临时表，然后外部的 select 语句对临时数据进行操作 
undefined：未定义，默认。
系统会根据自己的判断来确定具体使用哪种算法：merge，temptable，大部分的情 况下，系统会使用 merge，因为 merge 的效率比 temptable 高  
创建视图指定算法 
create algorithm=temptable view 视图名字 as select 语句 

### 数据备份 
mysql 提供了两种方式对数据进行备份 
1. 对数据内容进行备份（表中的数据） 
2. 对数据结构及其内容进行备份（表的结构语句+数据内容），备份的是 SQL 语句 ，数据内容备份 
将表中的数据值（没有字段名字），通过某种形式保存到外部文件当中 
语法：select 字段列表 into outfile 文件路径 [fileds 格式] [lines 格式] from 表名 
select * into outfile 'd:/back.sql' from sss;
注意：备份数据内容的时候，外部对应的数据文件必须不存在，只能新增，不能修改  
fileds 格式  
enclosed by：字段用什么包裹，默认是没有，是’’  
terminated by：字段与字段直接用什么分开，默认的是\t  
escaped by：字段如果碰到特殊符号使用什么转义，默认\\ lines 格式  
terminated by：行以什么结束，默认是\r\n  
starting by：行以什么开始，默认是’’ 

### 数据的还原操作 
将外部对应的文件信息里面的内容读取出来放到对应的数据表中，所有的数据还原必须与数据备份时使用的格式完 全一致。 
语法：load data infile 文件名字 into table 表名 [fileds 格式] [lines 格式] 
load data infile 'd:/back.sql' into table sss;

### SQL 备份 
就是将数据表的结构，以及数据进行备份，但是备份的形式是以 SQL 语句的形式存在。  
#### mysql 提供了一个备份的客户端，mysqldump.exe   
备份语法  mysqldump.exe 连接认证（hPup） 数据库 数据表,数据表… > 数据文件路径 
mysqldump -h127.0.0.1 -P3306 -uroot -p*** mydatabase sss > d:/back.sql
导入：
mysqldump -h127.0.0.1 -P3306 -uroot -p*** mydatabase < d:/back.sql

内部方式：SQL 语句还原  
语法：source 数据源（数据路径） 
数据库备份的优缺点 
1. 优点：能够将全部的数据进行备份，还原操作非常方便 
2. 缺点：必须备份全部数据

#### 数据文件备份 
直接将数据库的 Data 目录下的对应的表文件夹进行备份。  
备份需要区分存储引擎： Myisam：直接备份表对应的三个文件 frm，myd，myi，如果想要在其他数据库中用，直接将三个文件放进去即可  
InnoDB：需要备份表的结构文件 frm，还需要备份数据存储文件 ibdata1，如果想要在其他数据库用（如果是同一个 数据库环境，直接移动 frm 文件），如果要跨环境（需要覆盖 ibdata1 文件） 

### 事务处理 
事务处理指的是当一组事务进行时，必须要满足全部条件的才算执行成功，任何一个执行失败都将导致整个的事务 操作失败。  
SQL 语句是以行为单位执行。所以一个事务，往往是多条 SQL 语句需要执行。 
1. 开启事务 语法：start/begin transaction; 
2. 先执行一条 SQL 语句，但是该记录并不直接写入到数据库，等待 
3. 再执行其他 SQL 语句 
4. 如果全部都执行成功，再进行数据同步（把数据写入到数据库），如果有一个步骤失败，所有的操作全部放弃 
a) 成功语法：commit 
b) 失败语法：rollback   

系统中默认是采用非事务模式进行数据操作，在系统中有一个变量记录着数据操作的方式。   
只要修改 autocommit = OFF，就可以改变系统对于事务的处理模式。 
#### 事务特点 
原子性：Atomicity，一个事务是一个整体，要么全部成功，要么全部失败
一致性：consistency，在数据操作的前后，数据库的数据没有被改变，知道事务提交 
隔离性：isolation，在事务处理的过程中，其他的客户端数据的操作不受影响（主要指查看） 
如果在一个事务正在处理的时候，另外一个客户端，对同一条正在事务中处理的数据进行更新的时候，那么需要等 待事务的提交之后才能执行。  
持久性：事务一旦提交，那么整个修改将不可逆转 

### 触发器 
就是定义一段代码，给某个数据（一张表的一条记录）给绑定上，当记录对应的事件发生的时候，这段代码就会被 自动的执行。 与 js 的绑定事件是一回事。  
触发器语法 
delimiter 临时符号  
create trigger 触发器名字 触发时间 事件类型 on 表名 for each row 
begin  
//触发器的内容;  
//可以是各种 SQL 语句，一般是增删改;  
//流程控制：if，while; 
end 临时符号 
delimiter ; -- 改回语句结束符  
触发器中的内容都是以行为单位，每行都有一个结束符号，结束符号是分号。所以在创建触发器之前，都需要临时 的修改语句结束符：delimiter 临时符号  
触发时间：有两种  before：在记录操作前  after：在记录操作后 
事件类型：三种，增删改  
同一种触发器（时间和类型）只能在一张表有一个。
一张表最多能有多少个触发器？6 个触发器  
删除触发器：drop trigger 触发器名字 

### mysql 变量 
两种：
#### 系统变量，自定义变量  
系统变量：系统定义好的变量，如 autocommit，character_set 系列  
系统变量，用户不能定义系统变量，但是可以修改和使用  使用：使用 select 获取变量的值，但是因为 select 默认会将所有的字符串当做一个表的字段来查询，所以如果 是变量需要使用@符号来访问  
语法：select @@系统变量   select @@autocommit;   
查看所有变量：show variables;  
修改变量 局部修改：set 变量名 = 值  
全局修改：修改 mysql 的配置文件 my.ini  
#### 自定义变量 
定义变量的语法：set @变量名 = 值 查看：select @变量名 
mysql 为了区分=（比较符号），特别设定了一个赋值符号：:= set @变量名 := 值；   
可以从 select 得到的结果中，将值直接赋值给变量 
语法：select 字段列表 from 表 into 变量列表 
1. 字段列表必须等于变量列表 
2. select 语句只允许获取一行记录 

变量作用域     
外部定义的变量叫做全局变量，全局变量与 js 中的全局变量一样，能够在函数内部被使用；  
局部变量：declare 变量 数据类型 局部变量不能在函数外部访问。 
系统函数 
substring：字符串截取   
substring 是按照字符长度截取  
char_length：字符的长度  
length：字节长度  
instr：判断字符串是否在目标字符串中，返回字符串的起始位置（字符位置）  
lpad：左填充，左边填充内容直到字符串到达目标长度 
insert：向目标字符串中替换字符串  
strcmp：比较

### 自定义函数 
定义函数 
语法：
create function 函数名(参数列表) returns 数据类型  
begin   
//函数体   
//返回值  
end  
参数列表：参数名 数据类型 
调用自定义函数 
语法：select 函数名(参数列表)  
查看函数 
语法：show function status;查看所有函数   
删除函数 
语法：drop function 函数名 

函数内部结构 
函数内部默认是顺序结构，但是可以使用分支结构和循环结构 
分支结构 
if 分支结构 语法：  
if 条件 
then   
//语句  
else   
//语句 
end 
if; 

### 定义存储过程 
存储过程定义语法  
create procedure 过程名字(参数列表)  
begin   
//过程体  
end 

调用存储过程 
因为存储过程没有返回值，所以不能使用 select 调用（select 只能调用函数和字段） 
语法：call 过程名字(参数列表)

查看过程 
与查看函数类似：show procedure status 

删除过程 
语法：drop procedure 过程名 

参数列表 
存储过程的参数与函数有点不同 过程对于参数有三种自己的定义的类型  in：该参数只能从外部传入，不能从内部传出去，只能读取外部的值  out：只能从内部把数据传出去，不能读取变量在外部定义的值，只能在过程内部对其进行赋值和访问  inout：既能从外部传入，又能从内部传出，既可以读取外部的值，又可以在内部进行赋值，从而实现对外部的 值的修改。  
语法：in 参数名字 参数类型